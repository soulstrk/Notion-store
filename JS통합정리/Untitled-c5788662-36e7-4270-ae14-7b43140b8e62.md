# 통합정리

---

- Element.classList

    자바스크립트의 classList는 해당 엘리먼트의 클래스 요소들을 읽을 수 있다.

    classList.add 와 classList.remove 등으로 해당 엘리먼트를 조작할 수 있는 메서드를 사용할 수 도있다.

    contains("ClassName") 

# Window 객체

---

window는 브라우저 전체를 담당하고, window객체는 브라우저에서 지원해주는 객체

window는 브라우저 document는 페이지(탭) 이라고 생각하자

노드에서는 window객체가 없다. 브라우저에서 지원해주는 객체이기 때문

## scope chain

---

전역변수와 지역변수의 관계에서 스코프 체인이란 개념이 나옵니다.

내부 함수에서는 외부 함수의 변수에 접근이 가능하지만 외부 함수에서는 내부 함수의 변수에 접근할 수 없습니다.

- 예제1

    ![](-7b3254e1-116c-40a9-9366-93f79d5a063duntitled)

    inner 함수는 name 변수를 찾기위해 일단 자기 자신의 스코프에서 찾고 없으면 한 단계 올라가 outer 스코프에서 찾고,

    없으면 다시 올라가 결국 window객체에 있는 전역 스코프에서 찾습니다.

    - 이렇게 꼬리를 물고 계속 범위를 넓히면서 찾는 관계를 스코프 체인이라 부릅니다.

## lexical scpoping

---

- 스코프는 함수를 호출할 때가 아니라 선언할 때 생깁니다. (정적 스코프라고도 불립니다)
- 예제1

    ![](-a3b71acc-c65d-4480-b2e1-fecd8954611auntitled)

    log 함수가 선언 되는 순간 name을 찾습니다.

    그리고 자신의 스코프에 name이 없어서 결국 전역 객체의 name을 참조하게 되는데 그래서

    wrapper 함수에서 log함수를 호출해도 선언했을 때 참조하던 name ('zero')를 가르키는 것 입니다.

## 실행 컨텍스트

---

- 예제1

    ![](-beb603fe-37fa-4e32-8458-97cc61a39312untitled)

    - 결과값이 어떻게 될까?

        렉시컬 스코핑에 의해 nero, hello zero

처음 코드를 실행하는 순간 모든 것을 포함하는 전역 컨텍스트가 생깁니다.

페이지가 종료될 때까지 유지됩니다.

전역 컨텍스트 말고도 함수 컨텍스트가 있는데, 함수를 호출할 때마다 함수 컨텍스트가 하나씩 더 생깁니다.

- 컨텍스트의 원칙 4가지
    1. 먼저 전역 컨텍스트 하나 생성 후, 함수 호출 시마다 컨텍스트가 생깁니다.
    2. 컨텍스트 생성 시 컨텍스트 안에 변수객체(arguments, variable), scope chain, this가 생성됩니다.
    3. 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프체인을 따라 올라가며 찾습니다.
    4. 함수 실행이 마무리되면 해당 컨텍스트는 사라집니다. (클로저 제외) 페이지가 종료되면 전역 컨텍스트가 사라집니다.

## 호이스팅

---

- 예제1

    ![](-ae56886b-1783-4347-9b95-b28a042c0129untitled)

호이스팅이란 변수를 선언하고 초기화했을 때 선언부분이 최상단으로 끌어올려지는 현상을 의미합니다.

- 함수선언식일 때는 식 자체가 통째로 끌어올려집니다 ( 함수 표현식일 때는 X )

## 클로저

---

- 비공개 변수를 가질 수 있는 환경에 있는 함수가 클로저입니다.
- 비공개 변수는 클로저 함수 내부에 생성한 변수도 아니고, 매개변수도 아닌 변수를 의미합니다.
- 클로저를 말할 때는 스코프/컨텍스트/비공개 변수와 함수의 관계를 항상 같이 말해주어야 합니다.

- 예제1

    ![](-a8cb12c1-6faf-4146-b367-6e6999d461c2untitled)

    여기서 closure함수를 호출할 때

    closure 컨텍스트를 보면

    ![](-9869664d-7e92-4255-bd80-654d55b9c074untitled)

    이렇게 makeClosure 변수객체를 스코프 체인으로 가지게 됩니다.

    그래서 name에 접근할 때 자기자신의 스코프에서 찾고 makeClosure 스코프에서 찾을 수 있습니다.

- 이벤트리스너를 for문으로 연결했을 때 왜 오류가 나는지?

    ![](-41abb3e2-166c-48d0-8541-30c3a9a5984funtitled)

    바로 클로져를 사용하지 않아서 그렇습니다.

    lexical scoping에 따라 함수는 선언할 때 스코프가 생성됩니다.

    즉 이벤트리스너 안의 i는 외부의 i를 계속 참조하고 있는 겁니다. i는 반복문 종류 후 최종적으로 5가 되기 때문에

    결국 alert  결과가 모두 5가 됩니다.

    ![](-28ec5474-d0ee-46fe-a97a-1108eb9c6ae5untitled)

## 호출스택

---

- 예제1

    ![](-2e97217f-1c86-4ce0-a68e-9b9510dcefe3untitled)

    ![](-ce39f905-113b-48d4-bcdc-81b9c30539e9untitled)

## 이벤트 루프

---

이벤트 루프틑 실행 컨텍스트와 함께 필수적으로 알고 있어야 하는 개념입니다.

자바스크립트는 보통 싱글 쓰레드라고 불리는데, 바로 메인 쓰레드인 이벤트 루프가 싱글 쓰레드이기 때문입니다.

- 예제1

    ![](-df645ba5-8a4d-4cd9-91a8-086b0392395cuntitled)

    ![](-1c35dbc5-d1e0-43ee-aec7-99c1aaef4b04untitled)

- 이벤트 루프 그림

    ![](-b321c93a-2cb9-4201-86d4-e84c37da966cuntitled)

    ![](-f318cca8-02dc-4684-a4a5-4ba284fcb1e2untitled)

    이벤트 루프틑 항상 대기하고 있다가 호출 스택이 비워지면(전역 컨텍스트 main실행이 종료되면) 태스크 큐에서 함수를 하나씩 호출 스택으로 밀어 올립니다.

    백그라운드에서 3초를 정확하게 세어 주어도 호출 스택에 함수들이 가득차 있다면 3초 후에 실행되지 않을 수도 있습니다.

    setTimeout의 초가 정확하지 않을 수도 있는 이유입니다.

## 제이쿼리

---

find() : 어떤 요소의 '하위' 요소중에 찾는 것!